
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>greedySearchMag</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-05-23"><meta name="DC.source" content="greedySearchMag.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span> [mag, curScore, iter, gs] = greedySearchMag(covMat, nSamples, tol, verbose)
    nVars=size(covMat,1);
    <span class="comment">% begin from the empty mag</span>
    isAncestor = false(nVars);
    stepAncestor = zeros(nVars);
    isParent= false(nVars);
    isBidir = false(nVars);
    whichPair=nan;

    <span class="comment">% initially each node is a component</span>
    mag =zeros(nVars);
    [nComps, sizes, comps, inComponent]= concomp(mag);
    nsf = -nSamples/2;
    scores = zeros(1,nComps);
    <span class="keyword">for</span> iComp =1:nComps
        [compMag, district] = componentMag(comps{iComp}, nVars, mag, isParent);
        <span class="comment">% scores(iComp) = logdet(2*pi*covMat(district, district))+(nSamples-1)/nSamples;</span>
        scores(iComp) = score_contrib(compMag, comps{iComp}, district, sizes(iComp), covMat,nSamples, tol);
    <span class="keyword">end</span>
    nEdges=0;
    tmpSll = nsf*sum(scores);

    <span class="comment">%curScore = -2*tmpSll+log(nSamples)*(nVars+nEdges);</span>
    curScore = -2*tmpSll+bicPenalty(nSamples,nVars, nEdges);
    iter =0;

    pairs = nchoosek(1:nVars, 2);
    nPairs = length(pairs);

    bool=true;
    <span class="keyword">while</span> bool
        <span class="keyword">if</span> verbose
            fprintf(<span class="string">'Entering iteration %d, curScore: [%.4f], nComponents: %d, nEdges: %d\n'</span>, iter, curScore, nComps, nEdges);
        <span class="keyword">end</span>
        iter=iter+1;
        allowed = true(nPairs, 4);
        stepScores = nan(nPairs, 4);
        scoreContribs = cell(nPairs, 4);
        <span class="keyword">for</span> iPair =1:nPairs
            <span class="keyword">if</span> iPair==whichPair <span class="comment">% if you just changed this edge, continue</span>
                <span class="keyword">continue</span>;
            <span class="keyword">end</span>
            from = pairs(iPair, 1); to = pairs(iPair, 2);
            <span class="comment">%fprintf('\n-----pair %d -  %d ------\n',from ,to);</span>

            <span class="comment">% do you create a cycle?</span>
            <span class="keyword">if</span> stepAncestor(from, to)&gt;1
                <span class="comment">%fprintf('%d---&gt;%d in the graph\n', from, to)</span>
                allowed(iPair, 1:3) = [true false false];
            <span class="keyword">elseif</span> stepAncestor(to, from)&gt;1
                <span class="comment">%fprintf('%d---&gt;%d in the graph\n', to, from)</span>
                allowed(iPair, 1:3) = [false true false];
            <span class="keyword">end</span>

            <span class="comment">% can you create a cycle to---&gt;bdFrom&lt;-&gt;bdTo----&gt;from</span>
            [bdFrom, bdTo] = find(isBidir);
            <span class="keyword">for</span> iBDedge=1:length(bdFrom)
                <span class="keyword">if</span> isAncestor(from, bdFrom(iBDedge)) &amp;&amp; isAncestor(bdTo(iBDedge), to)
                    allowed(iPair, 1)=false;
                <span class="keyword">elseif</span> isAncestor(to, bdFrom(iBDedge)) &amp;&amp; isAncestor(bdTo(iBDedge), to)
                    allowed(iPair, 2)=false;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">% is the edge already in the graph?</span>
            <span class="keyword">if</span> mag(from, to)==0
                allowed(iPair, 4) = false;
            <span class="keyword">else</span>
                <span class="keyword">if</span> isParent(from, to)
                <span class="comment">%fprintf('%d-&gt;%d already in the graph\n', from, to)</span>
                allowed(iPair, 1)=false;
                <span class="keyword">elseif</span> isParent(to, from)
                <span class="comment">%fprintf('%d-&gt;%d already in the graph\n', to, from)</span>
                allowed(iPair, 2)=false;
                <span class="keyword">elseif</span> mag(from, to)==2 &amp;&amp; mag(to, from)==2
                <span class="comment">%fprintf('%d&lt;-&gt;%d already in the graph\n', from, to)</span>
                allowed(iPair, 3)=false;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">% add edge from-&gt;to</span>
            <span class="comment">% you do not need to update the connected components, only rescore</span>
            <span class="comment">% component (from);</span>
           <span class="comment">% fprintf(' \t 1 \t')</span>
            <span class="keyword">if</span> allowed(iPair, 1)
                 [stepScores(iPair, 1), scoreContribs{iPair, 1}] = <span class="keyword">...</span>
                     addDirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
            <span class="comment">%else fprintf('\t %d-&gt;%d not allowed\n',  from, to);</span>
            <span class="keyword">end</span>
            <span class="comment">% add edge to-&gt;from</span>
            <span class="comment">%fprintf(' \t 2 \t')</span>
            <span class="keyword">if</span> allowed(iPair, 2)
                  [stepScores(iPair, 2), scoreContribs{iPair, 2}] = <span class="keyword">...</span>
                      addDirectedEdge(to, from, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
            <span class="comment">%else fprintf('\t %d-&gt;%d not allowed\n', to, from);</span>
            <span class="keyword">end</span>
            <span class="comment">% add edge from&lt;-&gt;to</span>
            <span class="comment">%fprintf(' \t 3 \t')</span>
            <span class="keyword">if</span> allowed(iPair, 3)
                <span class="comment">% update components</span>
              [stepScores(iPair, 3), scoreContribs{iPair, 3}] = <span class="keyword">...</span>
                      addBidirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
            <span class="keyword">end</span>
               <span class="comment">%else fprintf('\t %d&lt;-&gt;%d not allowed\n', from, to);</span>
            <span class="comment">%fprintf(' \t 4 \n')</span>
            <span class="keyword">if</span> allowed(iPair, 4)
                <span class="comment">% if the edge is bidirected</span>
                <span class="keyword">if</span> mag(from,to)==2 &amp;&amp; mag(to, from)==2
                    [stepScores(iPair, 4), scoreContribs{iPair, 4}] = <span class="keyword">...</span>
                        removeBidirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
                <span class="keyword">else</span>
                    <span class="keyword">if</span> mag(from, to)==2
                         [stepScores(iPair, 4), scoreContribs{iPair, 4}] = removeDirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
                    <span class="keyword">elseif</span> mag(to, from)==2
                        [stepScores(iPair, 4), scoreContribs{iPair, 4}] = removeDirectedEdge(to, from, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="comment">%else fprintf('\t %d %d not allowed\n', from, to);</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span> <span class="comment">% end for iPair</span>
        <span class="comment">% choose best performing action, update descendants, parents</span>
        [minScores,actions] = nanmin(stepScores, [],  2);
        [minScore, whichPair] = nanmin(minScores);
        <span class="keyword">if</span> minScore&lt;curScore
            from = pairs(whichPair,1); to= pairs(whichPair,2);
            <span class="comment">% flag= true you have removed a directed edge and you have to</span>
            <span class="comment">% update ancestor matrix</span>
            flag=false;
            <span class="keyword">switch</span> actions(whichPair)
            <span class="keyword">case</span> 1
                <span class="keyword">if</span> verbose; fprintf(<span class="string">'\t \t Adding edge %d-&gt;%d\n'</span>, from, to);<span class="keyword">end</span>
                <span class="keyword">if</span> mag(from, to)==3;
                    flag=true; nEdges= nEdges-1;
                <span class="keyword">end</span>
                mag(from, to)=2; mag(to, from)=3; nEdges= nEdges+1;
                [isParent, isAncestor, stepAncestor] = updateAncestors(from, to, mag, isParent, isAncestor, stepAncestor, flag);
            <span class="keyword">case</span> 2
                <span class="keyword">if</span> verbose; fprintf(<span class="string">'\t \t Adding edge %d-&gt;%d\n'</span>, to, from);<span class="keyword">end</span>
                <span class="keyword">if</span> mag(to, from)==3;
                    flag=true; nEdges= nEdges-1;
                <span class="keyword">end</span>
                mag(from, to)=3; mag(to, from)=2; nEdges= nEdges+1;
                [isParent, isAncestor, stepAncestor] = updateAncestors(to, from, mag, isParent, isAncestor, stepAncestor, flag);
            <span class="keyword">case</span> 3
                <span class="keyword">if</span> verbose;fprintf(<span class="string">'\t \t Adding edge %d&lt;-&gt;%d\n'</span>, to, from);<span class="keyword">end</span>
                [nComps, sizes, comps, inComponent] = updateConcomp(from, to, nComps, sizes, comps, inComponent);
                isBidir(from,to)=true;isBidir(to, from)=true;
                <span class="keyword">if</span> mag(to, from)==3;
                    isParent(from, to)=false;
                    mag(to, from)=2;  nEdges= nEdges-1;
                    isAncestor = findancestors(mag);
                <span class="keyword">elseif</span> mag(from, to)==3
                    isParent(to, from)=false;
                    mag(from, to)=2; nEdges= nEdges-1;
                    isAncestor=findancestors(mag);
                <span class="keyword">else</span>
                    mag(from, to)=2; mag(to, from)=2;
                <span class="keyword">end</span>
                nEdges= nEdges+1;
            <span class="keyword">case</span> 4
                <span class="keyword">if</span> verbose;fprintf(<span class="string">'\t \t Removing edge %d*-*%d\n'</span>, to, from);<span class="keyword">end</span>
                [nComps, sizes, comps, inComponent] = updateConcompRem(from, to, nComps, sizes, comps, inComponent, mag);
                 <span class="keyword">if</span> mag(to, from)==3;
                    mag(to, from)=0;mag(from, to)=0;
                    isParent(from,to)=false;
                    [isAncestor,stepAncestor] = warshall2(double(isParent));
                <span class="keyword">elseif</span> mag(from, to)==3
                    isParent(to, from)=false;
                    mag(to, from)=0;mag(from, to)=0;
                    [isAncestor,stepAncestor] = warshall2(double(isParent));
                 <span class="keyword">else</span>
                    mag(from, to)=0; mag(to, from)=0;
                    isBidir(from,to)=false;isBidir(to, from)=false;
                 <span class="keyword">end</span>
                nEdges= nEdges-1;
                isParent(from, to)= false;isParent(to, from)=false;
            <span class="keyword">end</span>
            <span class="comment">% update score.</span>
            curScore = minScore;
            scores = scoreContribs{whichPair,actions(whichPair)};

            <span class="comment">% keep i-step matrices.</span>
            gs(iter).stepAncestor = stepAncestor;
            gs(iter).isAncestor = isAncestor;
            gs(iter).score=curScore;
            gs(iter).mag=mag;
        <span class="keyword">else</span>
        bool= false;
        <span class="keyword">if</span> verbose;fprintf(<span class="string">'Iteration %d: No score improvements, exiting greedy search\n'</span>, iter);<span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">% end while</span>
<span class="keyword">end</span>


<span class="keyword">function</span> [newScore, scoreContribs, newNComps, newSizes, newComps, newInComponent, newMag] = addDirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol)

    <span class="comment">% if the edge is bidirected you first have to update the components.</span>
    <span class="keyword">if</span> mag(to, from)==2 &amp;&amp; mag(from, to)==2
       [~, scores, newNComps, newSizes, newComps, newInComponent, newMag] = removeBidirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
    <span class="keyword">else</span>
        [newNComps, newSizes, newComps, newInComponent, newMag] = deal(nComps, sizes, comps, inComponent, mag);
    <span class="keyword">end</span>
    <span class="comment">% change mag</span>
    newMag(from, to)=2;newMag(to, from)=3;
    tmpIsParent = isParent;
    tmpIsParent(from, to)=true;
    <span class="comment">% if the edge was directed in reverse, you must also update</span>
    <span class="comment">% inComponent(from);</span>
    scoreContribs = scores;
    <span class="keyword">if</span> mag(from, to)==3;
        tmpIsParent(to, from)=false;
        component= comps{inComponent(from)};
        [compMag, district] = componentMag(component, nVars, newMag, tmpIsParent);
        scoreContribs(inComponent(from)) = score_contrib(compMag, component, district, sizes(inComponent(from)), covMat, nSamples, tol);
    <span class="keyword">end</span>
    <span class="comment">% update district</span>
    component = comps{inComponent(to)};
    [compMag, district] = componentMag(component, nVars, newMag, tmpIsParent);
    <span class="comment">% get new score</span>
    scoreContribs(inComponent(to)) = score_contrib(compMag, component, district, sizes(inComponent(to)), covMat, nSamples, tol);


    tmpSll = (-nSamples/2)*sum(scoreContribs);
    <span class="keyword">if</span> mag(from, to)==0
        nEdges = nEdges+1;
    <span class="keyword">end</span>
   <span class="comment">% newScore =-2*tmpSll+log(nSamples)*(nVars+nEdges);</span>
    newScore = -2*tmpSll+ bicPenalty(nSamples, nVars, nEdges);

<span class="comment">%     % test-remove</span>
<span class="comment">%     [~, ~, hatCovMat, ~] = RICF_fit(newMag, covMat, tol);</span>
<span class="comment">%     stats = likelihoodgauss(newMag, covMat, hatCovMat, nVars, nSamples);</span>
<span class="comment">%     if tmpSll-stats.sll&gt;tol</span>
<span class="comment">%         error('Something is wrong with scores in addDirectedEdge\n')</span>
<span class="comment">%     end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [newScore, scoreContribs, newNComps, newSizes, newComps, newInComponent, newMag] = addBidirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol)

    <span class="comment">% if edge was directed, update isParent</span>
    <span class="keyword">if</span> mag(to, from)==3
        isParent(from, to)=false;
    <span class="keyword">elseif</span> mag(from, to)==3
        isParent(to, from)=false;
    <span class="keyword">end</span>
    [newNComps, newSizes, newComps, newInComponent, k, m] = updateConcomp(from, to, nComps, sizes, comps, inComponent);
    <span class="comment">% add edge</span>
    newMag = mag;
    newMag(to, from)=2;newMag(from, to)=2;
    component= newComps{k};
    [compMag, district] = componentMag(component, nVars, newMag, isParent);
    <span class="comment">% keep old scores</span>
    keepScores =[1:m-1, m+1:nComps];
    <span class="keyword">if</span> k&lt;m
        newScores = scores(keepScores);
    <span class="keyword">else</span>
        newScores= scores;
    <span class="keyword">end</span>
    newScores(k)  = score_contrib(compMag, component, district, newSizes(k), covMat, nSamples,  tol);
    scoreContribs = newScores;

    tmpSll = (-nSamples/2)*sum(newScores);
    tmp_nEdges = nEdges+1;
    <span class="comment">%newScore =-2*tmpSll+log(nSamples)*(nVars+tmp_nEdges);</span>
    newScore = -2*tmpSll+ bicPenalty(nSamples, nVars, tmp_nEdges);

<span class="comment">%     % REMOVE</span>
<span class="comment">%     [~, ~, hatCovMat, ~] = RICF_fit(newMag, covMat, tol);</span>
<span class="comment">%     stats = likelihoodgauss(newMag, covMat, hatCovMat, nVars, nSamples);</span>
<span class="comment">%     % REMOVE</span>
<span class="comment">%     if tmpSll-stats.sll&gt;tol</span>
<span class="comment">%         error('Something is wrong with scores in 3\n')</span>
<span class="comment">%     end</span>

<span class="keyword">end</span>


<span class="keyword">function</span> [newScore, scoreContribs, nComps, sizes, comps, inComponent, newMag] = removeDirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol)
    newMag = mag;
    newMag(from, to)=0;newMag(to, from)=0;
    <span class="comment">% update district</span>
    tmpIsParent = isParent;
    tmpIsParent(from, to)=false;
    component = comps{inComponent(to)};
    [compMag, district] = componentMag(component, nVars, newMag, tmpIsParent);
    <span class="comment">% get new score</span>
    scoreContribs = scores;
    scoreContribs(inComponent(to)) = score_contrib(compMag, component, district, sizes(inComponent(to)), covMat, nSamples, tol);

    tmpSll = (-nSamples/2)*sum(scoreContribs);
    tmp_nEdges = nEdges+1;
    <span class="comment">%newScore =-2*tmpSll+log(nSamples)*(nVars+tmp_nEdges);</span>
     newScore = -2*tmpSll+ bicPenalty(nSamples, nVars, tmp_nEdges);

<span class="comment">%     % test-remove</span>
<span class="comment">%     [~, ~, hatCovMat, ~] = RICF_fit(newMag, covMat, tol);</span>
<span class="comment">%     stats = likelihoodgauss(newMag, covMat, hatCovMat, nVars, nSamples);</span>
<span class="comment">%     % test-remove</span>
<span class="comment">%     if tmpSll-stats.sll&gt;tol</span>
<span class="comment">%         error('Something is wrong with scores in removeDirectedEdge\n')</span>
<span class="comment">%     end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> [newScore, scoreContribs, newNComps, newNsizes, newComps, newInComponent, newMag] = removeBidirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol)
    <span class="comment">% remove edge</span>
    newMag = mag;
    newMag(to, from)=0;newMag(from, to)=0;
    <span class="comment">% update components</span>
    [newNComps, newNsizes, newComps, newInComponent, k, m] = updateConcompRem(from, to, nComps, sizes, comps, inComponent, mag);
    <span class="comment">% keep old scores</span>
    <span class="keyword">if</span> isnan(m) <span class="comment">% if you have not split the component.</span>
        tmp_scores=scores;
    <span class="keyword">else</span>
        keepScores =[1:k-1, k+1:m-1, m+1:newNComps];
        tmp_scores = nan(1, newNComps);
        tmp_scores(keepScores) = scores([1:k-1,k+1:nComps]);
        <span class="comment">% update m-score</span>
        component= newComps{m};
        [compMag, district] = componentMag(component, nVars, newMag, isParent);
        tmp_scores(m)  = score_contrib(compMag, component, district, newNsizes(m), covMat, nSamples,  tol);
    <span class="keyword">end</span>
    <span class="comment">%update k-score</span>
    component = newComps{k};
    [compMag, district] = componentMag(component, nVars, newMag, isParent);
    tmp_scores(k)  = score_contrib(compMag, component, district, newNsizes(k), covMat, nSamples,  tol);

    scoreContribs = tmp_scores;

    <span class="comment">% calculate new score</span>
    tmpSll = (-nSamples/2)*sum(tmp_scores);
    tmp_nEdges = nEdges-1;
    <span class="comment">%newScore =-2*tmpSll+log(nSamples)*(nVars+tmp_nEdges);</span>
    newScore = -2*tmpSll+ bicPenalty(nSamples, nVars, tmp_nEdges);

<span class="comment">%     % check if new score is correct - REMOVE</span>
<span class="comment">%     [~, ~, hatCovMat, ~] = RICF_fit(newMag, covMat, tol);</span>
<span class="comment">%     stats = likelihoodgauss(newMag, covMat, hatCovMat, nVars, nSamples);</span>
<span class="comment">%     if tmpSll-stats.sll&gt;tol</span>
<span class="comment">%         error('Something is wrong with scores in 4\n')</span>
<span class="comment">%         return;</span>
<span class="comment">%     end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [isParent, isAncestor, stepAncestor] = updateAncestors(from, to, mag, isParent, isAncestor, stepAncestor, flag)

    <span class="comment">% flag=true : You have removed a directed edge and you have to recompute all ancestors</span>
    <span class="keyword">if</span> flag
        isParent(to, from)=false;
        isParent(from, to)= true;
        [isAncestor, stepAncestor]= warshall2(isParent);
    <span class="keyword">else</span>
        isParent(from, to)= true;
        Anc_from = isAncestor(:, from);
        Desc_to = isAncestor(to, :);

        stepAncestor(Anc_from, to) = 2;
        stepAncestor(Anc_from, Desc_to) = 2;
        stepAncestor(from, Desc_to)= 2;

        Anc_from(from)= true;
        Desc_to(to)= true;
        isAncestor(Anc_from, Desc_to)= true;
    <span class="keyword">end</span>
    <span class="comment">%     isAncestor_tmp= findancestors(mag);</span>
    <span class="comment">% if ~isequal(isAncestor, isAncestor_tmp)</span>
    <span class="comment">%     error('Something is wrong with updating ancestors\n')</span>
    <span class="comment">% end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> bp = bicPenalty(nSamples, nVars, nEdges)

    bp = log(nSamples)*(2*nVars+nEdges);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Error using greedySearchMag (line 2)
Not enough input arguments.
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br></p></div><!--
##### SOURCE BEGIN #####
function [mag, curScore, iter, gs] = greedySearchMag(covMat, nSamples, tol, verbose)
    nVars=size(covMat,1);
    % begin from the empty mag
    isAncestor = false(nVars);
    stepAncestor = zeros(nVars);
    isParent= false(nVars);
    isBidir = false(nVars);
    whichPair=nan;

    % initially each node is a component
    mag =zeros(nVars);
    [nComps, sizes, comps, inComponent]= concomp(mag);
    nsf = -nSamples/2;
    scores = zeros(1,nComps);
    for iComp =1:nComps
        [compMag, district] = componentMag(comps{iComp}, nVars, mag, isParent);
        % scores(iComp) = logdet(2*pi*covMat(district, district))+(nSamples-1)/nSamples;
        scores(iComp) = score_contrib(compMag, comps{iComp}, district, sizes(iComp), covMat,nSamples, tol);
    end
    nEdges=0;
    tmpSll = nsf*sum(scores);

    %curScore = -2*tmpSll+log(nSamples)*(nVars+nEdges);
    curScore = -2*tmpSll+bicPenalty(nSamples,nVars, nEdges);
    iter =0;

    pairs = nchoosek(1:nVars, 2);
    nPairs = length(pairs);

    bool=true;
    while bool
        if verbose
            fprintf('Entering iteration %d, curScore: [%.4f], nComponents: %d, nEdges: %d\n', iter, curScore, nComps, nEdges);
        end
        iter=iter+1;  
        allowed = true(nPairs, 4);
        stepScores = nan(nPairs, 4);
        scoreContribs = cell(nPairs, 4);
        for iPair =1:nPairs
            if iPair==whichPair % if you just changed this edge, continue
                continue;
            end
            from = pairs(iPair, 1); to = pairs(iPair, 2);
            %fprintf('\nREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-pair %d -  %d REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH\n',from ,to);

            % do you create a cycle?
            if stepAncestor(from, to)>1
                %fprintf('%dREPLACE_WITH_DASH_DASH->%d in the graph\n', from, to)
                allowed(iPair, 1:3) = [true false false];
            elseif stepAncestor(to, from)>1
                %fprintf('%dREPLACE_WITH_DASH_DASH->%d in the graph\n', to, from)
                allowed(iPair, 1:3) = [false true false];
            end

            % can you create a cycle toREPLACE_WITH_DASH_DASH->bdFrom<->bdToREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH>from
            [bdFrom, bdTo] = find(isBidir);
            for iBDedge=1:length(bdFrom)
                if isAncestor(from, bdFrom(iBDedge)) && isAncestor(bdTo(iBDedge), to)
                    allowed(iPair, 1)=false;
                elseif isAncestor(to, bdFrom(iBDedge)) && isAncestor(bdTo(iBDedge), to)
                    allowed(iPair, 2)=false;
                end
            end
            % is the edge already in the graph?
            if mag(from, to)==0 
                allowed(iPair, 4) = false;
            else
                if isParent(from, to)
                %fprintf('%d->%d already in the graph\n', from, to)
                allowed(iPair, 1)=false;
                elseif isParent(to, from)
                %fprintf('%d->%d already in the graph\n', to, from)
                allowed(iPair, 2)=false;
                elseif mag(from, to)==2 && mag(to, from)==2
                %fprintf('%d<->%d already in the graph\n', from, to)
                allowed(iPair, 3)=false;
                end
            end
            % add edge from->to
            % you do not need to update the connected components, only rescore
            % component (from);
           % fprintf(' \t 1 \t')
            if allowed(iPair, 1)
                 [stepScores(iPair, 1), scoreContribs{iPair, 1}] = ...
                     addDirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
            %else fprintf('\t %d->%d not allowed\n',  from, to);
            end
            % add edge to->from
            %fprintf(' \t 2 \t')
            if allowed(iPair, 2)
                  [stepScores(iPair, 2), scoreContribs{iPair, 2}] = ...
                      addDirectedEdge(to, from, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
            %else fprintf('\t %d->%d not allowed\n', to, from);
            end
            % add edge from<->to        
            %fprintf(' \t 3 \t')
            if allowed(iPair, 3)
                % update components
              [stepScores(iPair, 3), scoreContribs{iPair, 3}] = ...
                      addBidirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
            end
               %else fprintf('\t %d<->%d not allowed\n', from, to);
            %fprintf(' \t 4 \n')
            if allowed(iPair, 4)
                % if the edge is bidirected
                if mag(from,to)==2 && mag(to, from)==2
                    [stepScores(iPair, 4), scoreContribs{iPair, 4}] = ...
                        removeBidirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
                else
                    if mag(from, to)==2
                         [stepScores(iPair, 4), scoreContribs{iPair, 4}] = removeDirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
                    elseif mag(to, from)==2
                        [stepScores(iPair, 4), scoreContribs{iPair, 4}] = removeDirectedEdge(to, from, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
                    end
                end
                %else fprintf('\t %d %d not allowed\n', from, to);
            end
        end % end for iPair
        % choose best performing action, update descendants, parents
        [minScores,actions] = nanmin(stepScores, [],  2);
        [minScore, whichPair] = nanmin(minScores);
        if minScore<curScore
            from = pairs(whichPair,1); to= pairs(whichPair,2);
            % flag= true you have removed a directed edge and you have to
            % update ancestor matrix
            flag=false;
            switch actions(whichPair)
            case 1
                if verbose; fprintf('\t \t Adding edge %d->%d\n', from, to);end
                if mag(from, to)==3;
                    flag=true; nEdges= nEdges-1;
                end
                mag(from, to)=2; mag(to, from)=3; nEdges= nEdges+1;
                [isParent, isAncestor, stepAncestor] = updateAncestors(from, to, mag, isParent, isAncestor, stepAncestor, flag);
            case 2
                if verbose; fprintf('\t \t Adding edge %d->%d\n', to, from);end
                if mag(to, from)==3;
                    flag=true; nEdges= nEdges-1;
                end
                mag(from, to)=3; mag(to, from)=2; nEdges= nEdges+1;
                [isParent, isAncestor, stepAncestor] = updateAncestors(to, from, mag, isParent, isAncestor, stepAncestor, flag);
            case 3
                if verbose;fprintf('\t \t Adding edge %d<->%d\n', to, from);end
                [nComps, sizes, comps, inComponent] = updateConcomp(from, to, nComps, sizes, comps, inComponent);
                isBidir(from,to)=true;isBidir(to, from)=true;
                if mag(to, from)==3;
                    isParent(from, to)=false;
                    mag(to, from)=2;  nEdges= nEdges-1;
                    isAncestor = findancestors(mag);
                elseif mag(from, to)==3
                    isParent(to, from)=false;
                    mag(from, to)=2; nEdges= nEdges-1;
                    isAncestor=findancestors(mag);
                else
                    mag(from, to)=2; mag(to, from)=2;  
                end
                nEdges= nEdges+1;
            case 4
                if verbose;fprintf('\t \t Removing edge %d*-*%d\n', to, from);end
                [nComps, sizes, comps, inComponent] = updateConcompRem(from, to, nComps, sizes, comps, inComponent, mag);
                 if mag(to, from)==3;
                    mag(to, from)=0;mag(from, to)=0;
                    isParent(from,to)=false;
                    [isAncestor,stepAncestor] = warshall2(double(isParent));
                elseif mag(from, to)==3
                    isParent(to, from)=false;
                    mag(to, from)=0;mag(from, to)=0; 
                    [isAncestor,stepAncestor] = warshall2(double(isParent));
                 else
                    mag(from, to)=0; mag(to, from)=0;  
                    isBidir(from,to)=false;isBidir(to, from)=false;
                 end
                nEdges= nEdges-1;
                isParent(from, to)= false;isParent(to, from)=false;
            end
            % update score.
            curScore = minScore;
            scores = scoreContribs{whichPair,actions(whichPair)};

            % keep i-step matrices.
            gs(iter).stepAncestor = stepAncestor;
            gs(iter).isAncestor = isAncestor;
            gs(iter).score=curScore;
            gs(iter).mag=mag;
        else 
        bool= false;
        if verbose;fprintf('Iteration %d: No score improvements, exiting greedy search\n', iter);end
        end
    end % end while
end


function [newScore, scoreContribs, newNComps, newSizes, newComps, newInComponent, newMag] = addDirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol)
    
    % if the edge is bidirected you first have to update the components.
    if mag(to, from)==2 && mag(from, to)==2
       [~, scores, newNComps, newSizes, newComps, newInComponent, newMag] = removeBidirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol);
    else
        [newNComps, newSizes, newComps, newInComponent, newMag] = deal(nComps, sizes, comps, inComponent, mag);        
    end
    % change mag
    newMag(from, to)=2;newMag(to, from)=3;
    tmpIsParent = isParent;
    tmpIsParent(from, to)=true;
    % if the edge was directed in reverse, you must also update
    % inComponent(from);
    scoreContribs = scores;
    if mag(from, to)==3;
        tmpIsParent(to, from)=false;
        component= comps{inComponent(from)};
        [compMag, district] = componentMag(component, nVars, newMag, tmpIsParent);
        scoreContribs(inComponent(from)) = score_contrib(compMag, component, district, sizes(inComponent(from)), covMat, nSamples, tol);
    end 
    % update district
    component = comps{inComponent(to)}; 
    [compMag, district] = componentMag(component, nVars, newMag, tmpIsParent);
    % get new score
    scoreContribs(inComponent(to)) = score_contrib(compMag, component, district, sizes(inComponent(to)), covMat, nSamples, tol);
       
   
    tmpSll = (-nSamples/2)*sum(scoreContribs);
    if mag(from, to)==0
        nEdges = nEdges+1;
    end
   % newScore =-2*tmpSll+log(nSamples)*(nVars+nEdges);
    newScore = -2*tmpSll+ bicPenalty(nSamples, nVars, nEdges);

%     % test-remove
%     [~, ~, hatCovMat, ~] = RICF_fit(newMag, covMat, tol); 
%     stats = likelihoodgauss(newMag, covMat, hatCovMat, nVars, nSamples);
%     if tmpSll-stats.sll>tol
%         error('Something is wrong with scores in addDirectedEdge\n')
%     end
end

function [newScore, scoreContribs, newNComps, newSizes, newComps, newInComponent, newMag] = addBidirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol)

    % if edge was directed, update isParent
    if mag(to, from)==3 
        isParent(from, to)=false;
    elseif mag(from, to)==3
        isParent(to, from)=false;
    end
    [newNComps, newSizes, newComps, newInComponent, k, m] = updateConcomp(from, to, nComps, sizes, comps, inComponent);
    % add edge
    newMag = mag;
    newMag(to, from)=2;newMag(from, to)=2;
    component= newComps{k};
    [compMag, district] = componentMag(component, nVars, newMag, isParent);
    % keep old scores
    keepScores =[1:m-1, m+1:nComps];
    if k<m
        newScores = scores(keepScores);
    else
        newScores= scores;
    end
    newScores(k)  = score_contrib(compMag, component, district, newSizes(k), covMat, nSamples,  tol);
    scoreContribs = newScores;
    
    tmpSll = (-nSamples/2)*sum(newScores);
    tmp_nEdges = nEdges+1;
    %newScore =-2*tmpSll+log(nSamples)*(nVars+tmp_nEdges);
    newScore = -2*tmpSll+ bicPenalty(nSamples, nVars, tmp_nEdges);

%     % REMOVE
%     [~, ~, hatCovMat, ~] = RICF_fit(newMag, covMat, tol); 
%     stats = likelihoodgauss(newMag, covMat, hatCovMat, nVars, nSamples);
%     % REMOVE
%     if tmpSll-stats.sll>tol
%         error('Something is wrong with scores in 3\n')
%     end

end


function [newScore, scoreContribs, nComps, sizes, comps, inComponent, newMag] = removeDirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol)
    newMag = mag;
    newMag(from, to)=0;newMag(to, from)=0;
    % update district
    tmpIsParent = isParent;
    tmpIsParent(from, to)=false;
    component = comps{inComponent(to)}; 
    [compMag, district] = componentMag(component, nVars, newMag, tmpIsParent);
    % get new score
    scoreContribs = scores;
    scoreContribs(inComponent(to)) = score_contrib(compMag, component, district, sizes(inComponent(to)), covMat, nSamples, tol);
    
    tmpSll = (-nSamples/2)*sum(scoreContribs);
    tmp_nEdges = nEdges+1;
    %newScore =-2*tmpSll+log(nSamples)*(nVars+tmp_nEdges);
     newScore = -2*tmpSll+ bicPenalty(nSamples, nVars, tmp_nEdges);

%     % test-remove
%     [~, ~, hatCovMat, ~] = RICF_fit(newMag, covMat, tol); 
%     stats = likelihoodgauss(newMag, covMat, hatCovMat, nVars, nSamples);
%     % test-remove
%     if tmpSll-stats.sll>tol
%         error('Something is wrong with scores in removeDirectedEdge\n')
%     end
end


function [newScore, scoreContribs, newNComps, newNsizes, newComps, newInComponent, newMag] = removeBidirectedEdge(from, to, nEdges, nComps, sizes, comps, inComponent, mag, covMat, isParent, scores, nSamples, nVars,  tol)
    % remove edge
    newMag = mag;
    newMag(to, from)=0;newMag(from, to)=0;
    % update components 
    [newNComps, newNsizes, newComps, newInComponent, k, m] = updateConcompRem(from, to, nComps, sizes, comps, inComponent, mag);
    % keep old scores
    if isnan(m) % if you have not split the component.
        tmp_scores=scores;
    else
        keepScores =[1:k-1, k+1:m-1, m+1:newNComps];
        tmp_scores = nan(1, newNComps);
        tmp_scores(keepScores) = scores([1:k-1,k+1:nComps]);
        % update m-score
        component= newComps{m};
        [compMag, district] = componentMag(component, nVars, newMag, isParent);
        tmp_scores(m)  = score_contrib(compMag, component, district, newNsizes(m), covMat, nSamples,  tol);
    end
    %update k-score
    component = newComps{k};
    [compMag, district] = componentMag(component, nVars, newMag, isParent);
    tmp_scores(k)  = score_contrib(compMag, component, district, newNsizes(k), covMat, nSamples,  tol);

    scoreContribs = tmp_scores;
    
    % calculate new score
    tmpSll = (-nSamples/2)*sum(tmp_scores);
    tmp_nEdges = nEdges-1;
    %newScore =-2*tmpSll+log(nSamples)*(nVars+tmp_nEdges);
    newScore = -2*tmpSll+ bicPenalty(nSamples, nVars, tmp_nEdges);
    
%     % check if new score is correct - REMOVE 
%     [~, ~, hatCovMat, ~] = RICF_fit(newMag, covMat, tol); 
%     stats = likelihoodgauss(newMag, covMat, hatCovMat, nVars, nSamples);
%     if tmpSll-stats.sll>tol
%         error('Something is wrong with scores in 4\n')
%         return;
%     end
end

function [isParent, isAncestor, stepAncestor] = updateAncestors(from, to, mag, isParent, isAncestor, stepAncestor, flag)

    % flag=true : You have removed a directed edge and you have to recompute all ancestors
    if flag
        isParent(to, from)=false;
        isParent(from, to)= true;
        [isAncestor, stepAncestor]= warshall2(isParent);
    else
        isParent(from, to)= true;
        Anc_from = isAncestor(:, from);
        Desc_to = isAncestor(to, :);

        stepAncestor(Anc_from, to) = 2;
        stepAncestor(Anc_from, Desc_to) = 2;
        stepAncestor(from, Desc_to)= 2;

        Anc_from(from)= true;
        Desc_to(to)= true;
        isAncestor(Anc_from, Desc_to)= true;
    end
    %     isAncestor_tmp= findancestors(mag);
    % if ~isequal(isAncestor, isAncestor_tmp)
    %     error('Something is wrong with updating ancestors\n')
    % end
end

function bp = bicPenalty(nSamples, nVars, nEdges)

    bp = log(nSamples)*(2*nVars+nEdges);
end
##### SOURCE END #####
--></body></html>